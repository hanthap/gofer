<html>
<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
<script>

//--------------------------------------------------------------------

console.clear();


let margin = {
  top: 100,
  right: 100,
  bottom: 100,
  left: 100
};

let svg_width = 900,
    svg_height = 600
;

//--------------------------------------------------------------------

class MyNode {
    constructor( id, x, y, r, parent ) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.r = r;
        this.parent = parent;
    }

    get FillColour() {
        return 'red';
    }

    get Height() {
        return 2*this.r;
    }

    get Width() {
        return 3*this.r;
    }

    get ImageSource() {
        return 'Tara photo.jpg';
    }
    get Opacity() {
        return Math.random();
    }

}

//----------------------------------------------------------------------------------------------

class MyRect extends MyNode {

    constructor( id, x, y, r, parent ) {
        super( id, x, y, r, parent )
    }

    get FillColour() { // overloaded member
        return 'green';
    }

}
//----------------------------------------------------------------------------------------------

let nodes = [
    new MyNode( 1, 100, 200, 30, 2 ),
    new MyRect( 2, -150, 250, 20, null ),
    new MyRect( 3, 300, 200, 40, 2 ),
    new MyRect( 4, 250, 150, 30 ),
    new MyNode( 5, 300, -200, 40, 4 )
];

//----------------------------------------------------------------------------------------------

// pragma "extend the class" simply by adding custom methods directly to the D3 prototype
// points to a javascripty approach to OOP encapsulation etc.

d3.selection.prototype.AddChildRects = function() { 
    this // initially a selection of 'g' elements
    .append('rect') // create a CHILD 'rect' for each selected 'g' element & return the result AS A NEW SELECTION
      .attr('width', d => d.Width ) // set attribute of each element in the fresh selection (= newly-added child rects)
      .attr('height', d => d.Height )
      .attr('fill', d => d.FillColour )
      .attr('opacity', 0.2)

}

d3.selection.prototype.AddChildCircles = function() { 
    this
    .append('circle')
      .attr('r', d => d.r)
      .attr('fill', d => d.FillColour)
      .attr('opacity', 0.6)
      .attr('stroke', 'black')
      .attr('stroke-width', 1)
      ;
}

d3.selection.prototype.AddHtmlDivs = function() { 

    divs = this // expecting a selection of g nodes which happen to contain a visible shape (circle or rect)
    .append("foreignObject") // add a (second) child element to each g node & return these, as a new selection
        .attr("x", d=>-d.r) // pixel offset relative to the parent 'g' element
        .attr("y", d=>-d.r)
        .attr("width", d=> d.Width)
        .attr("height", d=> d.Height)
        .attr('opacity', d=> d.Opacity) // important!
        .append("xhtml:div") // add a (grandchild) DIV element inside the foreignObject (we need the strictness of XHTML when inside an SVG) 
            .style("font-size", "8px")
            .style("justify-content", "center")
            .style("display", "flex")
            .style("height", "100%")
            .style("width", "100%")
            .style("align-items", "center")
            .style("font-family", "Helvetica")
            //.style("padding", "5px")
    ;

    return divs; // a selection of DIV elements ready for freestyle HTML code
}

  //--------------------------------------------------------------------

let svg = d3.select('body')
    .append('svg')
    .attr('height', svg_height)
    .attr('width', svg_width)
    .append('g') // this 'mother of all groups' will later contain all composite 'g' nodes
    .attr('transform', 'translate(' + svg_width / 2 + ',' + svg_height / 2 + ')'); // assume this applies to the top g node, not the outer svg
    // result is an element object, NOT bound to a data node

//--------------------------------------------------------------------
top_group = svg.selectAll("g");  // returns a custom D3 Selection object with members _groups and _parents. 
// member "_groups" is an EMPTY Array of NodeList objects.  _parents is an Array of 1x 'g' elements
// it's an instance of the Selection class. NOT a built-in Javascript iterator
// behaves like an array but also has extra methods. It's a chainable API (returns 'this') meaning you can apply multiple operations in sequence eg .attr(), .style(), 
// supports iteration with .each() or .nodes() 
// .nodes() will return a standard array

top_folder_groups = top_group // requires a D3 Selection object as returned by selectAll(), supporting chainable API
    .data(  // partition the selected elements into 3 subsets (enter, exit and update) according to their current data bindings
        nodes.filter(d=>d.parent == null), // an Array of qualifying data nodes, to be linked with the D3 Selection of DOM elements  
        d=>d.id // (optional) explicit key function to decide which subset each selected element belongs to (enter, exit or update)
        // D3 takes the returned ID value and stores it in the DOM element, as a custom data attr called 'data-id', useful for filtered selections later
        ) // if no key function the default logic is to simply compare the 2 list counts and put the surplus (last N) data nodes into the "enter" subset
    .enter() // switch to the "enter" subset and create special PLACEHOLDER elements. Returns the list of new placeholders, as a selection
    .append('g') // input selection is from _enter[] therefore special placeholder elements, so these are CONVERTED to 'g' instead of creating a child
        // returns a selection with all the newly converted elements
        .attr('data-myid', d=>d.id); // "data-" attributes are HTML's way to tag an element with arbitrary key-value pairs, without side effects
    // you can retrieve ALL custom data attributes of an HTML element via its "dataset" member. The "data-" prefix is already trimmed.
    // RESULT: top_folder_groups is a custom object with class members "_groups" and "_parents". Both are Arrays of Arrays.
    // member "_groups" is an array of 2x BOUND 'g' elements.   
    // BOUND means they each have a "__data__" member that references a particular data node (datum)
    // the referenced datum object stores all the properties that we defined explicitly in "nodes" above, PLUS a few others managed by d3: vx, vy, index
    // It retains all the object's class methods - but is not given special D3 methods. We can achieve OOP polymorphism and invoke overloaded methods

circle_groups = top_folder_groups
    .data(nodes.filter(d=>d.parent != null)) // partition the selected elements into 3 subsets (enter, exit and update) according to their current data bindings
    .enter() // switch to the _enter[] subset and create placeholder elements
    .append('g') // convert each placeholder to a 'g' element, ready to add child shapes
    ;

// populate the g elements with shapes & images, by invoking the encapsulated methods that we added to the standard D3 prototype

top_folder_groups.AddChildRects(); 
circle_groups.AddChildCircles(); 
divs = top_folder_groups.AddHtmlDivs();

divs.html("<table><tr><td><img src='Tara photo.jpg' alt='a' width=40 height=50></img></td><tr><td>Tara</td></tr></table>") ; 
    // TO DO: how to make the <img> appear below rather than to the right
/*
    div.append("img") // populate the DIV with 
            .attr("src", d => d.ImageSource)
            .attr("width", 40)
            .attr("height", 50)
            .attr("alt" , "hello" )
            .attr('opacity', 0.2);
*/

t = top_folder_groups // requires a D3 Selection object as returned by selectAll(), supporting chainable API
    .data(  // create a selection with 3 sub-selections. One for update, one for enter and one for exit.
        nodes, // an Array of qualifying data nodes, to be linked with the D3 Selection of DOM elements  
        d=>d.id // (optional) explicit key function that uniquely identifies the data point. This prevents random change in bindings later.
        // D3 takes the returned ID value and stores it in the DOM element, as a custom data attr called 'data-id', useful for filtered selections later
        )
;

//--------------------------------------------------------------------

let simulationCircle = d3.forceSimulation(nodes)
    .force("x", d3.forceX())
    .force("y", d3.forceY())
    .force('centre', d3.forceCenter()) 
   // .force("collide", d3.forceCollide() )
    .on("tick", ticked)
//         .tick(60) 
          ;

          //--------------------------------------------------------------------

function ticked() {
    circle_groups.attr("transform", d => `translate(${d.x-d.r/4}, ${d.y-d.r/4})`);
    top_folder_groups.attr("transform", d => `translate(${d.x-3*d.r/2}, ${d.y-d.r})`);
}

//--------------------------------------------------------------------
</script>
</body>
</html>
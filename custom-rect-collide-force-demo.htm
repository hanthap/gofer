<html>
<head>
    <script src="https://d3js.org/d3.v7.min.js"></script>

</head>
<body>
    <script>

function segmentIntersection(a1, a2, b1, b2) {
    // Ensure a1 <= a2 and b1 <= b2
    const [leftBound, rightBound] = [Math.max(a1, b1), Math.min(a2, b2)];

    // Check if there's an actual intersection
    return leftBound <= rightBound ? [leftBound, rightBound, rightBound-leftBound] : [null,null,0];
}
//--------------------------------------------------------------------

        let margin = {
          top: 100,
          right: 100,
          bottom: 100,
          left: 100
        };
        
        let width = 800,
          height = 600,
          padding = 0, // separation between same-color rects
          clusterPadding = 1, // separation between different-color rects
          maxRadius = 80;
        
        let nNodes = 3, // total number of nodes
          nClusters = 1, // number of distinct clusters
          z = d3.scaleOrdinal(d3.schemeCategory10),
          clusters = new Array(nClusters);
        
        let svg = d3.select('body')
          .append('svg')
          .attr('height', height)
          .attr('width', width)
          .append('g').attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');
        
          // generate a random dataset of nodes
        let nodes = d3.range(nNodes).map(() => {
          let i = Math.floor(Math.random() * nClusters), // randomly assign node to a cluster
            radius = Math.random() * maxRadius,
            d = {
              cluster: i,
              x : Math.random() * width,
              y : Math.random() * height,
              height: radius * ( 1+Math.random() ),
              width: radius * ( 1+Math.random() ),
              area: height * width // could use this as "inertial mass" for attractive force?
            };
            d.area = d.height * d.width;
            // anchor each cluster to its largest member datum node
          if (!clusters[i] || (d.area > clusters[i].area)) clusters[i] = d;
          return d;
        });
        console.clear();
        console.log(nodes);
        
        let rects = svg.append('g')
          .datum(nodes)
          .selectAll('.rect')
          .data(d => d)
          .enter().append('rect')
          .attr('height', (d) => d.height)
          .attr('width', (d) => d.width)
          .attr('fill', (d) => z(d.cluster))
          .attr('opacity', 0.6)
          .attr('stroke', 'black')
          .attr('stroke-width', 1);
        
        let simulation = d3.forceSimulation(nodes)
          .velocityDecay(0.4)
          .alpha(1)
          .force("x", d3.forceX().strength(.03))
          .force("y", d3.forceY().strength(.03))
          .force('centre', d3.forceCenter().strength(1))
      //    .force("cluster", clustering) //<<------- CUSTOM FORCE 
          .force("collide", collide) // <<-------- CUSTOM FORCE
          .on("tick", ticked);
        
        function ticked() {
            // set the DOM element's position using its new (top-left corner) coordinates, as last updated in datum
          rects
            .attr('x', (d) => d.x)
            .attr('y', (d) => d.y);
        }
        
        // Custom 'clustering' force implementation.
        // aim is to move each node towards the biggest rect in its cluster
        function clustering(alpha) {
          nodes.forEach(function(n) {
            var c = clusters[n.cluster];
            if (c === n) return;
            // maybe we can just leavet it to the collision function to resolve ALL overlaps?
            var // what's the smallest gap now (distance between the 2 closest non-overlapping sides)? 
              xGapRight = Math.max( 0, c.x - ( n.x + n.width ) ),  // +ve means cluster is fully to the right of n, so n.x will increase (and c.x will decrease)
              xGapLeft =  Math.max( 0, n.x - ( c.x + c.width ) ),  // +ve means cluster is fully to the left of n
              yGapBelow = Math.max( 0, c.y - ( n.y + n.height ) ), // +ve means cluster is fully below n
              yGapAbove = Math.max( 0, n.y - ( c.y + c.height ) ); // +ve means cluster is fully above n
            ;
          //   console.log([xGapRight,xGapLeft, yGapBelow,yGapAbove]);
            // The smallest non-zero gap is all that matters. We want this measure to approach zero, at a speed proportional to decreasing alpha
            xGap = [xGapRight,-xGapLeft].find( num => num != 0 );
            yGap = [yGapBelow,-yGapAbove].find( num => num != 0 );
            g = [xGap,yGap].filter( num => num !== null); // ignore nulls
            gap = g.map(Math.abs); // ignore sign
            minGap = Math.min(...gap); // what is the magnitude of the smaller gap?
           // console.log([xGap, yGap, minGap]);

            if (minGap > padding) {  // not already "touching"
            
              nudge_factor = minGap * alpha; //  goal is for n to touch the cluster node (but not overlap)
              if ( nudge_factor > 0 ) {
            //    console.log([xGap, yGap, minGap, nudge_factor]);

                 if (xGap > 0)  { 
//debugger;
                      n.x += xGap * nudge_factor * c.area; 
                     c.x -= xGap * nudge_factor * n.area;
                   }

                   if (yGap > 0)  { 
                      n.y += yGap * nudge_factor; 
                      c.y -= yGap * nudge_factor;
                   }

           }
            }
          });
        }
        // Custom 'collide' force implementation. doesn't treat the cluster node as special
        function collide(alpha) {
            // each shape will be assigned to a single bounding square, based ONLY on its top left corner 
            // => we'll have to consider its bottom right corner later, when visiting the quadtree
            var quadtree = d3.quadtree()
            .x((d) => d.x) 
            .y((d) => d.y)
            .addAll(nodes);
        
          nodes.forEach(function(n) {
            var r = n.width + maxRadius + Math.max(padding, clusterPadding),

              nx1 = n.x, // left 
              nx2 = n.x + n.width, // right
              ny1 = n.y, // top
              ny2 = n.y + n.height; // bottom

              // check this node n against POSSIBLY RELEVANT comparison nodes m... (skipping only where it's 100% safe to do so)
            quadtree.visit(function(
                  objRef, // [wrapper for] one comparison node 'm'
                  x1, y1, // top left of its "bounding square" in the quadtree
                  x2, y2 // bottom right of the same bounding square. Not very useful as m's bottom right corner could go further than this point
                ) { 
                  if ( x1 > nx2 || y1 > ny2 ) // top left of the new bounding square DEFINITELY does not overlap the rectangle of focus node n; 
                  // i.e. the (top left corner of) EVERY contained rect is FULLY rightward and/or downward relative to (bottom right corner of) n
                    // therefore, with no further ado, we can safely bypass this entire branch of the quadtree 
                    return true;
            // else the 2 rects MIGHT overlap, so let's find out...
              m = objRef.data; // just for readability
              if (m // non-empty
                && (m !== n) // no need to compare with self
                // can we save workload by processing one half of the matrix?
                && ( m.x <= n.x ) // m is leftward of n 
                && ( m.y <= n.y ) // m is upward of n
                ) 
                { 
                  
                    var
                        x_int = segmentIntersection( m.x, m.x+m.width, nx1, nx2), // horizontal intersection
                        y_int = segmentIntersection( m.y, m.y+m.height, ny1, ny2), // vertical intersection
                        x = x_int[2], y = y_int[2],
                        overlap_area = x * y ; 

                if (overlap_area) { // the 2 rects actually do overlap
                  nudge_factor = overlap_area * alpha / 1000; // for smooth animation
                  if ( x ) {
                  n.x -= x * nudge_factor; // nudge n away from m
                  m.x += x * nudge_factor; // nudge m in the opposite direction, away from n
                  }
                  if ( y ) {
                    n.y -= y * nudge_factor; // nudge n away from m
                    m.y += y * nudge_factor; // nudge m in the opposite direction, away from n
                  }
                }
              }
              return false; // do not skip this sector. It could include other rects that overlap node n
            });
          });
        }
        </script>
</body>
</html>